type Query {
    _about: String!
}
type Mutation {
    _about: String!
}
# resolves to a single type of error or condition
type BaseResponsePayload {
    code: Int!
    description: String!
}
# can return multiple kinds of errors at once
type BaseValidatedResponsePayload {
    validationErrors: [String!]
    conditionErrors: [String!]
    code: Int!
    description: String
}

type Roles {
    id: ID!
    name: String!
}

# USERS/Auth ENDPOINTS
#region
type Users{
    firstName: String!
    lastName: String!
    id: ID!
    email: String!
    sessionToken: String # hashed
    role: Roles!
    createdAt: String!
    lastLoginAt: String
    lastSignoutAt: String
    passwordHash: String!
    passwordLastUpdated: String!
    failedLoginAttempts: Int!
    failedLoginAttemptsTimestamps: [String!] # the list is not required as it can be empty
    passwordResetToken: String # hashed
    passwordResetRequestsCount: Int!
    passwordResetRequestsTimestamps: [String!]
}
# POST CREATE USER
# so should we doing the input as if hitting graphql directly and then some other auth business layer
# or should we model as if the auth layer was hit first then the layer queries graphql
# scenario 1 request is directly made to graphql, passing minimal parameters
input CreateUserInput {
    firstName: String!
    lastName: String!
    email: String!
    password: String!
    repeatPassword: String!
}
# scenario 2 business layer uses graphql to update data fields directly
input CreateUserBusinessLayerInput {
    firstName: String! #John
    lastName: String! #Smith
    email: String! #John.Smith@email.com
    role: ID! # id of client role
    createdAt: String! # timestamp passed by
    passwordHash: String!
    passwordLastUpdated: String!
    passwordResetRequestsCount: Int!
}
# POST LOGIN
input UserLoginInput {
    email: String!
    password: String!
}

# POST RESET
input UserResetPassword {
    resetToken: String!
    newPassword: String!
    repeatNewPassword: String!
}

extend type Mutation {
    createUser(input: CreateUserInput!) : BaseValidatedResponsePayload!
    loginUser(input: UserLoginInput): BaseValidatedResponsePayload!
    logoutUser: BaseValidatedResponsePayload! # assumes auth from a different layer is performed first?
    forgotPassword(email: String!) : BaseValidatedResponsePayload!
    resetPassword(input: UserResetPassword!) : BaseValidatedResponsePayload!
}
#endregion

# Permission endpoints
#region
type Permits {
    id: ID!
    role: Roles!
    permit: Permissions!
    isAllowed: Boolean!
}

type Permissions {
    id: ID!
    name: String!
    appliesToTable: String!
    appliesToField: String
}

#
input UserHasPermissionInput {
    user: ID # if no id is passed, assumes anonymous, check permits for public role
    permission: ID!
}

type UserHarPermissionPayload {
    isAllowed: Boolean!
    errors: String
    errorCode: Int
}

extend type Query {
    userHasPermission(input: UserHasPermissionInput! ) : UserHarPermissionPayload!
}
#endregion

type Categories {
    id: ID!
    name: String!
}

type Statuses {
    id: ID!
    name: String!
    forTable: String!
}


# Files endpoints
#region
type Files {
    id: Int!
    name: String!
    size: Int!
    url: String!
    createdAt: String!
}
# UPLOAD A FILE
input CreateFileInput {
    name: String!
    base64: String!
}

# GET A FILE, uncommon. Expectation is to be included in related queries.
# if not found then is null, no error is raised.
extend type Query {
    getFile(input: ID!): Files
    getFiles(input: [ID!]!): [Files]!
}

extend type Mutation {
    createFile(input: CreateFileInput! ): BaseResponsePayload!
    deleteFile(input: ID!): BaseResponsePayload!
}
#endregion

type Products {
    id: ID!
    disabled: Boolean!
    name: String!
    details: String!
    categories: [Categories!]!
    price: Float!
    stock: Int!
    createdBy: Users!
    createdAt: String!
    lastUpdatedBy: Users
    lastUpdatedAt: String
    images: [Files!] # list not required as item could not have an image (i.e. unpublished in progress)
    deleted: Boolean!
}



type Carts {
    id: ID!
    client: Users!
    product: Products!
    productQuantity: Int!
    createdAt: String!
}

type Orders {
    id: Int!
    client: Users
    payments: [Payments!]
    orderDetails: [OrderDetails!]!
    paymentStatus: Statuses!
    orderStatus: Statuses!
    createdAt: String!
}

type Payments {
    id: ID!
    closed: Boolean!
    paymentStatus: Statuses!
    createdAt: String!
    stripeEventId: String!
    stripeApiVersion: String!
    stripeWebhook: String # stringified JSON
    stripePaymentIntent: String #stringified JSON
}

type OrderDetails {
    id: ID!
    order: Orders!
    product: Int!
    productQuantity: Int!
    pricePurchasedAt: Float!
}

# Mailer Service Endpoints
#region
type EmailQueue {
    id: ID!
    queueStatus: Statuses!
    senderName: String
    senderEmail: String!
    recipientName: String
    recipientEmail: String!
    replyTo: String
    subject: String!
    textContent: String!
    htmlContent: String!
    attachments: [Files!]
}
# POST Email Job
input CreateEmailJobInput {
    senderName: String
    senderEmail: String!
    recipientName: String
    recipientEmail: String!
    replyToEmail: String
    subject: String
    textContent: String!
    htmlContent: String!
    attachments: [ID!]
}

# GET EMAIL JOBS (worker endpoint)
input GetEmailJobsInput {
    limit: Int!
    status: ID! # id of status to filter by
}
type GetEmailJobsPayload {
    jobs: [ID!] # NOT returning the jobs themselves as the worker would spike in memory usage. I rather it be chatty,
    #specially when the rate of the worker is defined by parameters and is fixed. Thus N+1 is not out of control.
    # another way could be to paginate to like 3 items, but still query should be converted to mutation if I want to also lock them.
    count: Int!
}

# PUT / UPDATE EMAIL STATUS (worker endpoint)
input UpdateEmailJobInput {
    jobId: ID!
    newStatus: ID!
}
type UpdateEmailJobPayload{
    code: Int! # could error as item is already locked status
    description: String!
    jobData: EmailQueue!
}

extend type Query{
    getEmailJobs(input: GetEmailJobsInput! ): GetEmailJobsPayload! # worker endpoint
}

extend type Mutation{
    createEmailJob(input: CreateEmailJobInput!): BaseValidatedResponsePayload!
    updateEmailJob(input: UpdateEmailJobInput!):  UpdateEmailJobPayload!
}
#endregion

# Likes endpoints
#region
type Likes {
    id: ID!
    client: Users!
    product: Products!
    createdAt: String!
}
# GET LIKES
input GetLikesInput {
    user: ID!
}
type LikesPayload {
    errors: String
    likes: Likes
}
extend type Query {
    getLikes(input: GetLikesInput!) : LikesPayload
}
# LIKE A PRODUCT and REMOVE A LIKED PRODUCT
input LikeProductInput {
    productLiked: ID!
    user: ID!
}
input RemoveLikeInput {
    likeToRemove: ID!
}
type LikeOperationPayload {
    errors: String
    likeResultCode: Int!
    likeResult : String
}
extend type Mutation {
    likeProduct(input: LikeProductInput!) : LikeOperationPayload!
    removeLike(input: RemoveLikeInput ) : LikeOperationPayload!
}
#endregion