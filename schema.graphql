type Query {
    _about: String!
}
type Mutation {
    _about: String!
}

type BaseResponsePayload {
    code: Int!
    description: String!
}

type Users{
    firstName: String!
    lastName: String!
    id: ID!
    email: String!
    sessionToken: String
    role: Roles!
    createdAt: String!
    lastLoginAt: String
    lastSignoutAt: String
    passwordHash: String!
    passwordLastUpdated: String!
    failedLoginAttempts: Int!
    failedLoginAttemptsTimestamps: [String!] # the list is not required as it can be empty
    passwordResetToken: String
    passwordResetRequestsCount: Int!
    passwordResetRequestsTimestamps: [String!]
}

type Roles {
    id: ID!
    name: String!
}

type Permits {
    id: ID!
    role: Roles!
    permit: Permissions!
    isAllowed: Boolean!
}

type Permissions {
    id: ID!
    name: String!
    appliesToTable: String!
    appliesToField: String
}

type Categories {
    id: ID!
    name: String!
}

type Statuses {
    id: ID!
    name: String!
    forTable: String!
}

# Files endpoints
#region
type Files {
    id: Int!
    name: String!
    size: Int!
    url: String!
    createdAt: String!
}
# UPLOAD A FILE
input CreateFileInput {
    name: String!
    base64: String!
}

# GET A FILE, uncommon. Expectation is to be included in related queries.
# if not found then is null, no error is raised.
extend type Query {
    getFile(input: ID!): Files
    getFiles(input: [ID!]!): [Files]!
}

extend type Mutation {
    createFile(input: CreateFileInput! ): BaseResponsePayload!
    deleteFile(input: ID!): BaseResponsePayload!
}
#endregion

type Products {
    id: ID!
    disabled: Boolean!
    name: String!
    details: String!
    categories: [Categories!]!
    price: Float!
    stock: Int!
    createdBy: Users!
    createdAt: String!
    lastUpdatedBy: Users
    lastUpdatedAt: String
    images: [Files!] # list not required as item could not have an image (i.e. unpublished in progress)
    deleted: Boolean!
}



type Carts {
    id: ID!
    client: Users!
    product: Products!
    productQuantity: Int!
    createdAt: String!
}

type Orders {
    id: Int!
    client: Users
    payments: [Payments!]
    orderDetails: [OrderDetails!]!
    paymentStatus: Statuses!
    orderStatus: Statuses!
    createdAt: String!
}

type Payments {
    id: ID!
    closed: Boolean!
    paymentStatus: Statuses!
    createdAt: String!
    stripeEventId: String!
    stripeApiVersion: String!
    stripeWebhook: String # stringified JSON
    stripePaymentIntent: String #stringified JSON
}

type OrderDetails {
    id: ID!
    order: Orders!
    product: Int!
    productQuantity: Int!
    pricePurchasedAt: Float!
}

# Mailer Service Endpoints
#region
type EmailQueue {
    id: ID!
    queueStatus: Statuses!
    senderName: String
    senderEmail: String!
    recipientName: String
    recipientEmail: String!
    replyTo: String
    subject: String!
    textContent: String!
    htmlContent: String!
    attachments: [Files!]
}
# POST Email Job
input CreateEmailJobInput {
    senderName: String
    senderEmail: String!
    recipientName: String
    recipientEmail: String!
    replyToEmail: String
    subject: String
    textContent: String!
    htmlContent: String!
    attachments: [ID!]
}
type CreateEmailJobPayload {
    validationErrors: [String!]
    conditionErrors: [String!]
    resultCode: Int!
    resultInfo: String
}
# GET EMAIL JOBS (worker endpoint)
input GetEmailJobsInput {
    limit: Int!
    status: ID! # id of status to filter by
}
type GetEmailJobsPayload {
    jobs: [ID!] # NOT returning the jobs themselves as the worker would spike in memory usage. I rather it be chatty,
    #specially when the rate of the worker is defined by parameters and is fixed. Thus N+1 is not out of control.
    # another way could be to paginate to like 3 items, but still query should be converted to mutation if I want to also lock them.
    count: Int!
}

# PUT / UPDATE EMAIL STATUS (worker endpoint)
input UpdateEmailJobInput {
    jobId: ID!
    newStatus: ID!
}
type UpdateEmailJobPayload{
    code: Int! # could error as item is already locked status
    description: String!
    jobData: EmailQueue!
}

extend type Query{
    getEmailJobs(input: GetEmailJobsInput! ): GetEmailJobsPayload! # worker endpoint
}

extend type Mutation{
    createEmailJob(input: CreateEmailJobInput!): CreateEmailJobPayload!
    updateEmailJob(input: UpdateEmailJobInput!):  UpdateEmailJobPayload!
}
#endregion

# Likes endpoints
#region
type Likes {
    id: ID!
    client: Users!
    product: Products!
    createdAt: String!
}
# GET LIKES
input GetLikesInput {
    user: ID!
}
type LikesPayload {
    errors: String
    likes: Likes
}
extend type Query {
    getLikes(input: GetLikesInput!) : LikesPayload
}
# LIKE A PRODUCT and REMOVE A LIKED PRODUCT
input LikeProductInput {
    productLiked: ID!
    user: ID!
}
input RemoveLikeInput {
    likeToRemove: ID!
}
type LikeOperationPayload {
    errors: String
    likeResultCode: Int!
    likeResult : String
}
extend type Mutation {
    likeProduct(input: LikeProductInput!) : LikeOperationPayload!
    removeLike(input: RemoveLikeInput ) : LikeOperationPayload!
}
#endregion